<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming Languages on Bryan Ford&#39;s Home Page</title>
    <link>https://bford.info/topics/Programming-Languages/</link>
    <description>Recent content in Programming Languages on Bryan Ford&#39;s Home Page</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Dec 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://bford.info/topics/Programming-Languages/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Matchertext: Towards Verbatim Interlanguage Embedding</title>
      <link>https://bford.info/pub/lang/matchertext/</link>
      <pubDate>Wed, 28 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/matchertext/</guid>
      <description>Bryan Ford Abstract: Embedding text in one language within text of another is commonplace for numerous purposes, but usually requires tedious and error-prone “escaping” transformations on the embedded string. We propose a simple cross-language syntactic discipline, matchertext, which enables the safe embedding a string in any compliant language into a string in any other language via simple “copy-and-paste” – in particular with no escaping, obfuscation, or expansion of embedded strings.</description>
    </item>
    
    <item>
      <title>Are Only Type Parameters Generic Enough for Go 2 Generics?</title>
      <link>https://bford.info/2019/07/29/go-generics/</link>
      <pubDate>Mon, 29 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/2019/07/29/go-generics/</guid>
      <description>The Go language appears to be getting slightly closer to supporting generics, with the recent release of a new proposal for generics based on type parameters and contracts.
I generally like the direction this proposal is going, with one significant reservation. I feel that the current proposal both unnecessarily limits how &amp;ldquo;generic&amp;rdquo; Go&amp;rsquo;s generics will be, and risks painting the language into a corner in the long term. This is because the proposal single-mindedly assumes that the only compile-time generic parameters we will ever want are type parameters, which seems like an unnecessary and undesirable restriction.</description>
    </item>
    
    <item>
      <title>GPUfs: The Case for Operating System Services on GPUs</title>
      <link>https://bford.info/pub/os/gpufs-cacm/</link>
      <pubDate>Mon, 01 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/gpufs-cacm/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Maple: Simplifying SDN Programming Using Algorithmic Policies</title>
      <link>https://bford.info/pub/net/maple-abs/</link>
      <pubDate>Tue, 13 Aug 2013 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/net/maple-abs/</guid>
      <description>Andreas Voellmy, Junchang Wang, Y. Richard Yang, Bryan Ford, and Paul Hudak ACM SIGCOMM 2013
August 12-16, 2013 Abstract: Software-Defined Networking offers the appeal of a simple, centralized programming model for managing complex networks. However, challenges in managing low-level details, such as setting up and maintaining correct and efficient forwarding tables on distributed switches, often compromise this conceptual simplicity. In this paper, we present Maple, a system that simplifies SDN programming by (1) allowing a programmer to use a standard programming language to design an arbitrary, centralized algorithm, which we call an algorithmic policy, to decide the behaviors of an entire network, and (2) providing an abstraction that the programmer-defined, centralized policy runs, conceptually, &amp;ldquo;afresh&amp;rdquo; on every packet entering a network, and hence is oblivious to the challenge of translating a high-level policy into sets of rules on distributed individual switches.</description>
    </item>
    
    <item>
      <title>Lazy Tree Mapping: Generalizing and Scaling Deterministic Parallelism</title>
      <link>https://bford.info/pub/os/lazy-tree-mapping/</link>
      <pubDate>Mon, 29 Jul 2013 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/lazy-tree-mapping/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>GPUfs: Integrating a File System with GPUs</title>
      <link>https://bford.info/pub/os/gpufs/</link>
      <pubDate>Wed, 20 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/gpufs/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Deterministic OpenMP</title>
      <link>https://bford.info/thesis/2012-aviram/</link>
      <pubDate>Thu, 20 Sep 2012 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/thesis/2012-aviram/</guid>
      <description>Amittai F. Aviram Ph.D. thesis advised by Bryan Ford
September 20, 2012 Abstract: Researchers widely agree that determinism in parallel programs is desirable. Although experimental parallel programming languages have long featured deterministic semantics, in mainstream parallel environments, developers still build on non-deterministic constructs such as mutexes, leading to time- or schedule-dependent heisenbugs. To make deterministic programming more accessible, we introduce DOMP, a deterministic extension to OpenMP, preserving the familiarity of traditional languages such as C and Fortran, and maintaining source-compatibility with much of the existing OpenMP standard.</description>
    </item>
    
    <item>
      <title>Scaling Software-Defined Network Controllers on Multicore Servers</title>
      <link>https://bford.info/pub/os/scaling-sdn-abs/</link>
      <pubDate>Sun, 01 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/scaling-sdn-abs/</guid>
      <description>Andreas Voellmy, Bryan Ford, Paul Hudak, and Y. Richard Yang Yale University Department of Computer Science
Technical Report YALEU/DCS/TR-1468
July 2012 Abstract: Software defined networks (SDN) introduce centralized controllers to drastically increase network programmability. The simplicity of a logical centralized controller, however, can come at the cost of controller programming complexity and scalability. In this paper, we present McNettle, an extensible SDN controller system whose control event processing throughput scales with the number of system CPU cores and which supports control algorithms requiring globally visible state changes occurring at flow arrival rates.</description>
    </item>
    
    <item>
      <title>Deterministic OpenMP for Race-Free Parallelism</title>
      <link>https://bford.info/pub/os/determ-openmp/</link>
      <pubDate>Thu, 26 May 2011 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/determ-openmp/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Workspace Consistency: A Programming Model for Shared Memory Parallelism</title>
      <link>https://bford.info/pub/os/workspace-consistency/</link>
      <pubDate>Sun, 06 Mar 2011 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/workspace-consistency/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Alpaca: Extensible Authorization for Distributed Services</title>
      <link>https://bford.info/pub/net/alpaca-abs/</link>
      <pubDate>Mon, 29 Oct 2007 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/net/alpaca-abs/</guid>
      <description>Chris Lesniewski-Laas, Bryan Ford, Jacob Strauss, Robert Morris, and M. Frans Kaashoek
Massachusetts Institute of Technology Published in 14th ACM Conference on Computer and Communications Security, Oct 29-Nov 2, 2007, Alexandria, VA. Abstract: Traditional Public Key Infrastructures (PKI) have not lived up to their promise because there are too many ways to define PKIs, too many cryptographic primitives to build them with, and too many administrative domains with incompatible roots of trust.</description>
    </item>
    
    <item>
      <title>Parsing Expression Grammars: A Recognition-Based Syntactic Foundation</title>
      <link>https://bford.info/pub/lang/peg/</link>
      <pubDate>Wed, 14 Jan 2004 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/peg/</guid>
      <description>Bryan Ford
Massachusetts Institute of Technology Symposium on Principles of Programming Languages, January 14-16, 2004, Venice, Italy Abstract For decades we have been using Chomsky&#39;s generative system of grammars, particularly context-free grammars (CFGs) and regular expressions (REs), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difficult both to express and to parse machine-oriented languages using CFGs.</description>
    </item>
    
    <item>
      <title>Packrat Parsing: Simple, Powerful, Lazy, Linear Time</title>
      <link>https://bford.info/pub/lang/packrat-icfp02/</link>
      <pubDate>Fri, 04 Oct 2002 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/packrat-icfp02/</guid>
      <description>Bryan Ford
Massachusetts Institute of Technology International Conference on Functional Programming, October 4-6, 2002, Pittsburgh Abstract Packrat parsing is a novel technique for implementing parsers in a lazy functional programming language. A packrat parser provides the power and flexibility of top-down parsing with backtracking and unlimited lookahead, but nevertheless guarantees linear parse time. Any language defined by an LL(k) or LR(k) grammar can be recognized by a packrat parser, in addition to many languages that conventional linear-time algorithms do not support.</description>
    </item>
    
    <item>
      <title>Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking</title>
      <link>https://bford.info/pub/lang/thesis/</link>
      <pubDate>Tue, 03 Sep 2002 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/thesis/</guid>
      <description>Bryan Ford
Master&#39;s Thesis
Massachusetts Institute of Technology Abstract Packrat parsing is a novel and practical method for implementing linear-time parsers for grammars defined in Top-Down Parsing Language (TDPL). While TDPL was originally created as a formal model for top-down parsers with backtracking capability, this thesis extends TDPL into a powerful general-purpose notation for describing language syntax, providing a compelling alternative to traditional context-free grammars (CFGs). Common syntactic idioms that cannot be represented concisely in a CFG are easily expressed in TDPL, such as longest-match disambiguation and &#34;</description>
    </item>
    
    <item>
      <title>Flick: A Flexible, Optimizing IDL Compiler</title>
      <link>https://bford.info/pub/lang/flick-pldi97-abs/</link>
      <pubDate>Sun, 15 Jun 1997 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/flick-pldi97-abs/</guid>
      <description>Eric Eide, Kevin Frei, Bryan Ford, Jay Lepreau, and Gary Lindstrom University of Utah, Department of Computer Science ACM SIGPLAN Conference on Programming Language Design and Implementation
June 15-18, 1997. Abstract: Modern operating systems must support a wide variety of services for a diverse set of users. Designers of these systems face a tradeoff between functionality and performance. Systems like Mach provide a set of general abstractions and attempt to handle every situation, which can lead to poor performance for common cases.</description>
    </item>
    
    <item>
      <title>Using Annotated Interface Definitions to Optimize RPC</title>
      <link>https://bford.info/pub/lang/presint3-abs/</link>
      <pubDate>Wed, 01 Mar 1995 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/presint3-abs/</guid>
      <description>Bryan Ford, Mike Hibler, and Jay Lepreau University of Utah, Department of Computer Science Technical Report UUCS-95-014
March 1995. Abstract: In RPC-based communication, it is useful to distinguish the RPC interface, which is the “network contract” be- tween the client and the server, from the presentation, which is the “programmer’s contract” between the RPC stubs and the code that calls or is called by them. Presentation is usually a fixed function of the RPC interface, but some RPC systems, such as DCE and Concert, support the notion of a flexible presentation or endpoint modifier, allowing controlled modification of the behavior of the stubs on each side without affecting the contract between the client and the server.</description>
    </item>
    
    <item>
      <title>Separating Presentation from Interface in RPC and IDLs</title>
      <link>https://bford.info/pub/lang/presint2-abs/</link>
      <pubDate>Thu, 01 Dec 1994 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/presint2-abs/</guid>
      <description>Bryan Ford, Mike Hibler, and Jay Lepreau University of Utah, Department of Computer Science Technical Report UUCS-95-018
December 1994. Abstract: In RPC-based communication, we term the interface the set of remote procedures and the types of their arguments; the presentation is the way these procedures and types are mapped to the target language environment in a particular client or server, including semantic requirements. For example, presentation includes the local names assigned to RPC stubs, the physical representation of a logical block of data (e.</description>
    </item>
    
    <item>
      <title>Microkernels Should Support Passive Objects</title>
      <link>https://bford.info/pub/os/passive-abs/</link>
      <pubDate>Thu, 09 Dec 1993 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/os/passive-abs/</guid>
      <description>Bryan Ford and Jay Lepreau Department of Computer Science, University of Utah International Workshop on Object Orientation in Operating Systems (IWOOOS)
December 9-10, 1993 Abstract: We believe that a passive object model, in which the active entities or threads migrate between passive objects, is more appropriate than an active object model, as the basic structure of a microkernel-based operating system. A passive object model provides enhanced performance and simplicity because it is more closely matched to the basic nature of microprocessors and the requirements of applications.</description>
    </item>
    
    <item>
      <title>Object-Oriented Display Refreshing</title>
      <link>https://bford.info/pub/lang/call-lists/</link>
      <pubDate>Wed, 01 Apr 1992 00:00:00 +0000</pubDate>
      
      <guid>https://bford.info/pub/lang/call-lists/</guid>
      <description> &amp;ldquo;CallLists is a refreshing way to keep your interactive programs up to date.&amp;rdquo; Bryan Ford
AmigaWorld Tech Journal
Volume 2 Number 2, April 1992 Article: PDF </description>
    </item>
    
  </channel>
</rss>
