-- Parser generated by Pappy - do not edit
module Triv where

import Pos
import Parse



eval :: String -> Integer
eval str = case trivExpression (trivParse "expression" str) of
	Parsed v _ _ -> v
	NoParse e -> error (show e)


data TrivDerivs = TrivDerivs {
	trivSub0 :: TrivDerivs0,
	trivChar :: Result TrivDerivs Char,
	trivPos :: Pos
}

instance Derivs TrivDerivs where
	dvChar d = trivChar d
	dvPos d = trivPos d

data TrivDerivs0 = TrivDerivs0 {
	trivSubAdditiveTail :: Result TrivDerivs ((Integer -> Integer)),
	trivSubMultitiveTail :: Result TrivDerivs ((Integer -> Integer)),
	trivSubPrimary :: Result TrivDerivs (Integer),
	trivSubDigitsTail :: Result TrivDerivs ((Integer -> Integer)),
	trivSubStarRule0 :: Result TrivDerivs ([Char])}

trivAdditiveTail = trivSubAdditiveTail . trivSub0
trivMultitiveTail = trivSubMultitiveTail . trivSub0
trivPrimary = trivSubPrimary . trivSub0
trivDigitsTail = trivSubDigitsTail . trivSub0
trivStarRule0 = trivSubStarRule0 . trivSub0

trivParse :: String -> String -> TrivDerivs
trivParse name text = trivDerivs (Pos name 1 1) text

trivDerivs :: Pos -> String -> TrivDerivs
trivDerivs pos text = dvs where
  dvs = TrivDerivs
    (trivDerivs0 dvs)
    chr pos
  chr = case text of
    [] -> NoParse (eofError dvs)
    (c:cs) -> Parsed c (trivDerivs (nextPos pos c) cs) (nullError dvs)

trivDerivs0 dvs = TrivDerivs0
	(trivParseAdditiveTail dvs)
	(trivParseMultitiveTail dvs)
	(trivParsePrimary dvs)
	(trivParseDigitsTail dvs)
	(trivParseStarRule0 dvs)

trivExpression :: TrivDerivs -> Result TrivDerivs (Integer)
trivExpression d =
  case trivStarRule0 d of
    Parsed _ d1 e1 ->
      case trivAdditive d1 of
        Parsed v d3 e3 ->
          case trivChar d3 of
            NoParse e5 ->
              Parsed ( v ) d3 (maximum [e5,e3,e1])
            Parsed _ _ e5 -> NoParse (maximum [e5,e3,e1])
        NoParse e3 -> NoParse (max e3 e1)
    NoParse e1 -> NoParse e1

trivParseAdditiveTail :: TrivDerivs -> Result TrivDerivs ((Integer -> Integer))
trivParseAdditiveTail d =
  pappyAlt1_1 (ParseError (trivPos d) []) where
    pappyAlt1_1 e1 =
      case trivSymbol d of
        Parsed "+" d3 e3 ->
          case trivMultitive d3 of
            Parsed r d5 e5 ->
              case trivAdditiveTail d5 of
                Parsed pappyTail d7 e7 ->
                  Parsed (\l -> pappyTail ( l + r )) d7 (maximum [e7,e5,e3,e1])
                NoParse e7 -> pappyAlt1_2 (maximum [e7,e5,e3,e1])
            NoParse e5 -> pappyAlt1_2 (maximum [e5,e3,e1])
        _ -> pappyAlt1_2 (max (ParseError (trivPos d) [Expected "+"]) e1)
    pappyAlt1_2 e1 =
      case trivSymbol d of
        Parsed "-" d3 e3 ->
          case trivMultitive d3 of
            Parsed r d5 e5 ->
              case trivAdditiveTail d5 of
                Parsed pappyTail d7 e7 ->
                  Parsed (\l -> pappyTail ( l - r )) d7 (maximum [e7,e5,e3,e1])
                NoParse e7 -> pappyAlt1_3 (maximum [e7,e5,e3,e1])
            NoParse e5 -> pappyAlt1_3 (maximum [e5,e3,e1])
        _ -> pappyAlt1_3 (max (ParseError (trivPos d) [Expected "-"]) e1)
    pappyAlt1_3 e1 =
      Parsed (\v -> v) d e1
    pappyAlt1_4 e1 = NoParse e1

trivAdditive :: TrivDerivs -> Result TrivDerivs (Integer)
trivAdditive d =
  case pappyResult1 of
    Parsed l d1 e1 ->
      case trivAdditiveTail d1 of
        Parsed t d3 e3 ->
          Parsed (t l) d3 (max e3 e1)
        NoParse e3 -> NoParse (max e3 e1)
    NoParse e1 -> NoParse e1
  where
    pappyResult1 =
      case trivMultitive d of
        Parsed v d3 e3 ->
          Parsed ( v ) d3 e3
        NoParse e3 -> NoParse e3

trivParseMultitiveTail :: TrivDerivs -> Result TrivDerivs ((Integer -> Integer))
trivParseMultitiveTail d =
  pappyAlt1_1 (ParseError (trivPos d) []) where
    pappyAlt1_1 e1 =
      case trivSymbol d of
        Parsed "*" d3 e3 ->
          case trivPrimary d3 of
            Parsed r d5 e5 ->
              case trivMultitiveTail d5 of
                Parsed pappyTail d7 e7 ->
                  Parsed (\l -> pappyTail ( l * r )) d7 (maximum [e7,e5,e3,e1])
                NoParse e7 -> pappyAlt1_2 (maximum [e7,e5,e3,e1])
            NoParse e5 -> pappyAlt1_2 (maximum [e5,e3,e1])
        _ -> pappyAlt1_2 (max (ParseError (trivPos d) [Expected "*"]) e1)
    pappyAlt1_2 e1 =
      case trivSymbol d of
        Parsed "/" d3 e3 ->
          case trivPrimary d3 of
            Parsed r d5 e5 ->
              case trivMultitiveTail d5 of
                Parsed pappyTail d7 e7 ->
                  Parsed (\l -> pappyTail ( l `div` r )) d7 (maximum [e7,e5,e3,e1])
                NoParse e7 -> pappyAlt1_3 (maximum [e7,e5,e3,e1])
            NoParse e5 -> pappyAlt1_3 (maximum [e5,e3,e1])
        _ -> pappyAlt1_3 (max (ParseError (trivPos d) [Expected "/"]) e1)
    pappyAlt1_3 e1 =
      case trivSymbol d of
        Parsed "%" d3 e3 ->
          case trivPrimary d3 of
            Parsed r d5 e5 ->
              case trivMultitiveTail d5 of
                Parsed pappyTail d7 e7 ->
                  Parsed (\l -> pappyTail ( l `mod` r )) d7 (maximum [e7,e5,e3,e1])
                NoParse e7 -> pappyAlt1_4 (maximum [e7,e5,e3,e1])
            NoParse e5 -> pappyAlt1_4 (maximum [e5,e3,e1])
        _ -> pappyAlt1_4 (max (ParseError (trivPos d) [Expected "%"]) e1)
    pappyAlt1_4 e1 =
      Parsed (\v -> v) d e1
    pappyAlt1_5 e1 = NoParse e1

trivMultitive :: TrivDerivs -> Result TrivDerivs (Integer)
trivMultitive d =
  case pappyResult1 of
    Parsed l d1 e1 ->
      case trivMultitiveTail d1 of
        Parsed t d3 e3 ->
          Parsed (t l) d3 (max e3 e1)
        NoParse e3 -> NoParse (max e3 e1)
    NoParse e1 -> NoParse e1
  where
    pappyResult1 =
      case trivPrimary d of
        Parsed v d3 e3 ->
          Parsed ( v ) d3 e3
        NoParse e3 -> NoParse e3

trivParsePrimary :: TrivDerivs -> Result TrivDerivs (Integer)
trivParsePrimary d =
  pappyAlt1_1 (ParseError (trivPos d) []) where
    pappyAlt1_1 e1 =
      case pappyResult3 of
        Parsed v d3 e3 ->
          Parsed ( v ) d3 (max e3 e1)
        NoParse e3 -> pappyAlt1_2 (max e3 e1)
      where
        pappyResult3 =
          case pappyResult5 of
            Parsed v d5 e5 ->
              case trivStarRule0 d5 of
                Parsed _ d7 e7 ->
                  Parsed ( v ) d7 (max e7 e5)
                NoParse e7 -> NoParse (max e7 e5)
            NoParse e5 -> NoParse e5
          where
            pappyResult5 =
              case pappyResult7 of
                Parsed l d7 e7 ->
                  case trivDigitsTail d7 of
                    Parsed t d9 e9 ->
                      Parsed (t l) d9 (max e9 e7)
                    NoParse e9 -> NoParse (max e9 e7)
                NoParse e7 -> NoParse e7
              where
                pappyResult7 =
                  case trivDigit d of
                    Parsed d d9 e9 ->
                      Parsed ( toInteger d ) d9 e9
                    NoParse e9 -> NoParse e9
    pappyAlt1_2 e1 =
      case trivSymbol d of
        Parsed "(" d3 e3 ->
          case trivAdditive d3 of
            Parsed v d5 e5 ->
              case trivSymbol d5 of
                Parsed ")" d7 e7 ->
                  Parsed ( v ) d7 (maximum [e7,e5,e3,e1])
                _ -> pappyAlt1_3 (maximum [(ParseError (trivPos d5) [Expected ")"]),e5,e3,e1])
            NoParse e5 -> pappyAlt1_3 (maximum [e5,e3,e1])
        _ -> pappyAlt1_3 (max (ParseError (trivPos d) [Expected "("]) e1)
    pappyAlt1_3 e1 = NoParse e1

trivParseDigitsTail :: TrivDerivs -> Result TrivDerivs ((Integer -> Integer))
trivParseDigitsTail d =
  pappyAlt1_1 (ParseError (trivPos d) []) where
    pappyAlt1_1 e1 =
      case trivDigit d of
        Parsed d d3 e3 ->
          case trivDigitsTail d3 of
            Parsed pappyTail d5 e5 ->
              Parsed (\v -> pappyTail ( v * 10 + toInteger d )) d5 (maximum [e5,e3,e1])
            NoParse e5 -> pappyAlt1_2 (maximum [e5,e3,e1])
        NoParse e3 -> pappyAlt1_2 (max e3 e1)
    pappyAlt1_2 e1 =
      Parsed (\v -> v) d e1
    pappyAlt1_3 e1 = NoParse e1

trivDigit :: TrivDerivs -> Result TrivDerivs (Int)
trivDigit d =
  case trivChar d of
    Parsed c d1 e1 ->
      case (isDigit c) of
        True ->
          Parsed ( digitToInt c ) d1 e1
        False -> NoParse e1
    NoParse e1 -> NoParse e1

trivSymbol :: TrivDerivs -> Result TrivDerivs (String)
trivSymbol d =
  case pappyResult1 of
    Parsed s d1 e1 ->
      case trivStarRule0 d1 of
        Parsed _ d3 e3 ->
          Parsed ( s ) d3 (max e3 e1)
        NoParse e3 -> NoParse (max e3 e1)
    NoParse e1 -> NoParse e1
  where
    pappyResult1 =
      case trivChar d of
        Parsed '+' d3 _ ->
          Parsed ("+") d3 (ParseError (trivPos d3) [])
        Parsed '-' d3 _ ->
          Parsed ("-") d3 (ParseError (trivPos d3) [])
        Parsed '*' d3 _ ->
          Parsed ("*") d3 (ParseError (trivPos d3) [])
        Parsed '/' d3 _ ->
          Parsed ("/") d3 (ParseError (trivPos d3) [])
        Parsed '%' d3 _ ->
          Parsed ("%") d3 (ParseError (trivPos d3) [])
        Parsed '(' d3 _ ->
          Parsed ("(") d3 (ParseError (trivPos d3) [])
        Parsed ')' d3 _ ->
          Parsed (")") d3 (ParseError (trivPos d3) [])
        _ -> NoParse (ParseError (trivPos d) [])

trivParseStarRule0 :: TrivDerivs -> Result TrivDerivs ([Char])
trivParseStarRule0 d =
  pappyAlt1_1 (ParseError (trivPos d) []) where
    pappyAlt1_1 e1 =
      case pappyResult3 of
        Parsed v d3 e3 ->
          case trivStarRule0 d3 of
            Parsed vs d5 e5 ->
              Parsed (v : vs) d5 (maximum [e5,e3,e1])
            NoParse e5 -> pappyAlt1_2 (maximum [e5,e3,e1])
        NoParse e3 -> pappyAlt1_2 (max e3 e1)
      where
        pappyResult3 =
          case trivChar d of
            Parsed c d5 e5 ->
              case (isSpace c) of
                True ->
                  Parsed ( c ) d5 e5
                False -> NoParse e5
            NoParse e5 -> NoParse e5
    pappyAlt1_2 e1 =
      Parsed ([]) d e1
    pappyAlt1_3 e1 = NoParse e1

