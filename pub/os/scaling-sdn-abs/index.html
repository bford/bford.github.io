<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      <meta name="Author" content="Bryan Ford">
    
    <title>
  Scaling Software-Defined Network Controllers on Multicore Servers &ndash; Bryan Ford&#39;s Home Page
</title>
    <link rel="shortcut icon" href="/img/favicon.ico"
	type="image/x-icon" />
    
    
    
  </head>

  <body 
  	
  	>
    
      <center>
<table style="background:white;padding:1px;border-spacing:5px">
<tr><td style="text-align:center">
<font color=black>
<a href="/"><font color=blue>Home</font></a> -
<a href="/topics"><font color=blue>Topics</font></a> -
<a href="/pub"><font color=blue>Papers</font></a> -
<a href="/talk"><font color=blue>Talks</font></a> -
<a href="/thesis"><font color=blue>Theses</font></a> -
<a href="/post"><font color=blue>Blog</font></a> -
<a href="/cv.pdf"><font color=blue>CV</font></a> -
<a href="/album/"><font color=blue>Photos</font></a> -
<a href="/funny/"><font color=blue>Funny</font></a>
</font>
</td></tr></table>
</center>
<p>

    

    
  <h1>Scaling Software-Defined Network Controllers on Multicore Servers</h1>
  
<center>
<STRONG>
Andreas Voellmy, Bryan Ford, Paul Hudak, and Y. Richard Yang
<br>

Yale University Department of Computer Science<br>
</STRONG>

<p>
<a href="https://cpsc.yale.edu/research/technical-reports/2012-technical-reports">Technical Report YALEU/DCS/TR-1468</a><br>
July 2012
</p>
</center>

<H3>Abstract:</H3>
Software defined networks (SDN) introduce centralized controllers to
drastically increase network programmability. The simplicity of a logical
centralized controller, however, can come at the cost of controller programming
complexity and scalability. In this paper, we present McNettle, an extensible
SDN controller system whose control event processing throughput scales with the
number of system CPU cores and which supports control algorithms requiring
globally visible state changes occurring at flow arrival rates. Programmers
extend McNettle by writing event handlers and background programs in a
high-level functional programming language extended with shared state and
memory transactions. We implement our framework in Haskell and leverage the
multicore facilities of the Glasgow Haskell Compiler (GHC) and runtime system.
Our implementation schedules event handlers, allocates memory, optimizes
message parsing and serialization, and buffers system calls in order to
optimize cache usage, OS processing, and runtime system overhead. We identify
and fix bottlenecks in the GHC runtime system and IO manager. Our experiments
show that McNettle can serve up to 5000 switches using a single controller with
46 cores, achieving throughput of over 14 million flows per second, near-linear
scaling up to 46 cores, and latency under 10 ms with loads consisting of up to
1500 switches.

<H3>Paper:
<a href="../scaling-sdn.pdf">PDF</a>
</H3>




    
      <br clear=all>
<hr>
<table style="width:100%;padding:10pt"><tr>

<td align="left">

	Topics:
	
		<a href="/topics/Operating-Systems/">Operating Systems</a>
	
		<a href="/topics/Scalability/">Scalability</a>
	
		<a href="/topics/Programming-Languages/">Programming Languages</a>
	
		<a href="/topics/Software-Defined-Networks/">Software Defined Networks</a>
	

</td>

<td align="right">
<a href="https://bford.info/">Bryan Ford</a>
</td>

</tr></table>

    
  </body>
</html>
