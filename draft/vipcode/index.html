<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
      <meta name="Author" content="Bryan Ford">
    
    <title>
  VIPcode: Encoding and Decoding Structured Data with Verifiable Interface Presentations (VIPs) &ndash; Bryan Ford&#39;s Home Page
</title>
    <link rel="shortcut icon" href="/img/favicon.ico"
	type="image/x-icon" />
    
    
    
  </head>

  <body 
  	
  	>
    
      <center>
<table bgcolor="black" cellspacing=1 cellpadding=4>
<tr><td bgcolor="white">
<font color=black>
<a href="/"><font color=blue>Home</font></a> -
<a href="/topics"><font color=blue>Topics</font></a> -
<a href="/pub"><font color=blue>Papers</font></a> -
<a href="/post"><font color=blue>Blog</font></a> -
<a href="/cv.pdf"><font color=blue>CV</font></a> -
<a href="/album/"><font color=blue>Photos</font></a> -
<a href="/funny/"><font color=blue>Funny</font></a>
</font>
</td></tr></table>
</center>
<p>

    

    
  <h1>VIPcode: Encoding and Decoding Structured Data with Verifiable Interface Presentations (VIPs)</h1>
  <p>In this post I would like to introduce
<a href="xxx">VIPcode</a>, a library that encodes and decodes structured data
specified by <em>verifiable interface presentations</em> or VIPs
in the <a href="https://golang.org">Go language</a>.
In brief, VIPs are <em>presentations</em> or mappings
of an abstract wire-format interface
into the concrete data types of a specific target language (in this case Go).
While embodying all information needed to marshal and unmarshall complex data,
VIPs may also be <em>verified</em> automatically for compliance
with a language-neutral interface specification,
such as a
<a href="https://developers.google.com/protocol-buffers/docs/proto3"><code>.proto</code> file</a>
or a
<a href="https://json-schema.org">JSON schema</a>.
While this initial VIPcode library is specific to Go,
the philosophy and development workflow it embodies is language-neutral,
could readily be ported to other languages, and I hope it will be.</p>
<h2 id="defining-interface-and-presentation-separately">Defining interface and presentation separately</h2>
<p>VIPcode is inspired by the idea of separately but synergistically specifying
the <em>interface</em> and <em>presentation</em> of interoperable structured data formats.
An <em>interface</em> definition is independent of any programming language,
and defines only the essence of the contract required for wire-compatibility.
A <em>presentation</em> definition, in contrast,
is specific to a target programming language such as Go,
and offers developers convenience and customizability in the way
a wire-format interface is mapped to in-memory data structures.
For example, while the <em>interface</em> might specify only
that a data value is an integer or list,
the interface&rsquo;s <em>presentation</em> might separately define
which specific language-specific integer or container type the value maps to.
VIPcode makes presentations <em>verifiable</em> or checkable
against a language-independent interface, however,
to ensure that a language-specific presentation
indeed conforms to its intended abstract interface.</p>
<p>This idea of separately defining presentation and interface
is one I proposed over two decades ago, in
<a href="/topics/Interface-Definition/">interface definition research</a>
done in the context of the now-obsolete
<a href="https://en.wikipedia.org/wiki/Mach_(kernel)">Mach kernel</a>
and the equally-obsolete
<a href="https://en.wikipedia.org/wiki/Common_Object_Request_Broker_Architecture">CORBA</a>
<a href="https://en.wikipedia.org/wiki/Interface_description_language">interface definition language (IDL)</a>.
The fundamental concept of separately specifying presentation and interface,
however, is an idea that I feel is far from obsolete
and worth updating to modern programming languages and IDLs.
Features of modern typesafe languages like
<a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>,
<a href="https://golang.org">Go</a>, and
<a href="https://developer.apple.com/swift/">Swift</a>
such as <a href="https://golang.org/pkg/reflect/">reflection</a>
and <a href="https://golang.org/ref/spec#Tag">struct tags</a>, in particular,
now make it convenient to embed presentation definitions
into the type definitions of the target language itself,
while ensuring that these presentations may be verified
against language-neutral interface definitions.</p>
<h2 id="specifying-interface-presentation-via-go-type-definitions">Specifying interface presentation via Go type definitions</h2>
<p>The VIPcode library offers functionally comparable to,
and wire-compatible with,
marshaling and unmarshaling stubs generated by
<a href="https://en.wikipedia.org/wiki/Interface_description_language">IDL compilers</a>
like
<a href="https://github.com/protocolbuffers/protobuf">protoc</a>.
VIPcode requires no IDL compiler, however,
but instead marshals and unmarshals data structures as specified directly
using <em>verifiable interface presentations</em> (VIP) definitions
embedded in the target language (Go).
VIPcode&rsquo;s presentation/interface separation philosophy
is not incompatible with stub compilation for performance, however,
as <a href="#perf">discussed below</a>.</p>
<p>As an example,
the following Go <code>struct</code> definition describes a data structure
that VIPcode can marshal or unmarshal
in either <a href="https://developers.google.com/protocol-buffers/">protobuf</a> or
<a href="https://en.wikipedia.org/wiki/JSON">JSON</a> format,
and other wire formats in the future:</p>
<pre><code>    type Example struct {
        b bool		// a boolean field
        i int		// an integer field
        f float32	// a 32-bit floating-point number
        s string	// a text string
        a []byte	// a variable-length byte array
        v [3]float32	// a fixed-length vector of three floats
        r []Example	// a recursive list of structs
    }
</code></pre>
<p>Using the
<a href="xxx">vipcode/protobuf</a> package,
you can marshal an instance of the <code>Example</code> struct into
protobuf wire format as follows:</p>
<pre><code>    var e Example
    // ... (fill in fields of e) ...
    buf, err := protobuf.Encode(&amp;e)
</code></pre>
<p>You can similarly unmarshal a serialized instance as follows:</p>
<pre><code>    err := protobuf.Decode(buf, &amp;e)
</code></pre>
<p>Using the
<a href="xxx">vipcode/json</a> package,
you can similarly marshal and unmarshal the same structure
into or out of JSON format.</p>
<h2 id="verifying-compliance-with-an-interface-definition-or-schema">Verifying compliance with an interface definition or schema</h2>
<p>As you can see from the examples above,
the vipcode codec for protobuf format does not require a <code>.proto</code> file
as with the standard
<a href="https://github.com/golang/protobuf">protobuf package for Go</a>.
Instead,
more like the existing
<a href="https://github.com/dedis/protobuf">reflective protobuf codec for Go</a>,
vipcode reflectively uses the <code>Example</code> <code>struct</code> definition in Go
to infer the wire-format interface.
This way, you don&rsquo;t need to guess or remember
which specific Go type or field naming style
(e.g., <code>with_underscores</code> or <code>camelCase</code>)
the IDL compiler will produce from a particular <code>.proto</code> file definition,
or dig through the long and unreadable output of <code>protoc</code> to figure that out.
You know the exact Go type and field name for use from your code
because <em>you defined it</em>.</p>
<p>While convenient,
this approach might be dangerous if you are trying to be interoperable
with a language-independent definition in a <code>.proto</code> file,
and vipcode unexpectedy infers a different wire-format type
from what you were expecting or from what the <code>.proto</code> file specifies.
This is a real risk in using our prior
<a href="https://github.com/dedis/protobuf">reflective protobuf codec</a>,
however convenient.
There are excellent reasons to use language-independent interface definitions,
and vipcode does not pretend otherwise.</p>
<p>But the vipcode philosophy is that the proper use of interface definition files
is not to <em>generate code from</em> them,
but rather to <em>verify</em> language-specific presentations <em>against</em> them.
This philosophy is consistent with the way <code>interface</code> types work
within the Go language itself, in fact.
You define an <code>interface</code> type separately
from object types you intend to conform to that interface,
and the Go compiler verifies that those objects indeed conform
by implementing the necessary methods with the correct signatures.</p>
<p>To demonstrate interface verification in vipcode,
suppose that you write (or were given)
a <code>.proto</code> file called <code>example.proto</code>
specifying this language-independent &ldquo;message&rdquo; definition:</p>
<pre><code>    message Example {
        bool b = 1;
        int32 i = 2;
        float f = 3;
        string s = 4;
        bytes a = 5;
        repeated float v = 6;
        repeated Example e = 7;
    }
</code></pre>
<p>In one of your <code>_test.go</code> files
for the package containing the Go <code>type Example struct</code> definition above,
you should include a test that looks like this:</p>
<pre><code>    import &quot;vipcode/protobuf&quot;

    func TestExampleProto(t *testing.T) {
        protobuf.TestProto(t, &quot;example.proto&quot;, &amp;Example{})
    }
</code></pre>
<p>This test will verify that the Go type of the object passed to <code>TestProto</code>
matches the language-independent message definition of the same name
in the <code>example.proto</code> file.</p>
<p>If you change the <code>Example</code> definition in either the Go type definition
or the <code>example.proto</code> file
to make their wire-formats incompatible,
then <code>TestExampleProto</code> will fail.
For example, since protobuf encoding uses different wire encodings
for signed and unsigned integers,
the test will fail if the field <code>i</code> is changed to an unsigned integer type
in one definition but not the other.</p>
<h2 id="some-ways-separate-presentation-definition-is-useful">Some ways separate presentation definition is useful</h2>
<p>For full details on the types and verification rules vipcode supports,
please see the package&rsquo;s <a href="xxx">README</a>
and <a href="xxx">API documentation</a>.
However, this section briefly covers a few ways in which
specifying target-language presentation separately from
language-interface can be useful when using vipcode.</p>
<h3 id="integers">Integers</h3>
<p>Although the protobuf wire format uses
<a href="https://developers.google.com/protocol-buffers/docs/encoding#varints">varints</a>
that can in principle encode arbitrary-precision integers,
the protobuf language constrains
<a href="https://developers.google.com/protocol-buffers/docs/proto3#scalar">integer scalars</a>
to be either 32-bit or 64-bit.
The Go language supports both fixed-width integer types like <code>int32</code>
and the &ldquo;generic&rdquo; machine-word integer type <code>int</code>, however,
and the latter is pervasively used throughout Go code
and often most convenient when we just need
&ldquo;an integer we&rsquo;re pretty sure is big enough for our purposes.&rdquo;
In <code>Relaxed</code> interface verification mode, therefore,
vipcode allows an <code>int32</code> or <code>int32</code> protobuf type to be
&ldquo;presented&rdquo; as an <code>int</code> type in Go.</p>
<h3 id="floating-point-types">Floating-point types</h3>
<h3 id="lists">Lists</h3>
<p>Go slices versus vectors</p>
<h2 id="inferring-and-verifying-against-protobuf-interface-definitions">Inferring and verifying against protobuf interface definitions</h2>
<p>Message field IDs: automatic, and manual</p>
<p>integer types</p>
<p>&hellip;</p>
<h2 id="inferring-and-verifying-against-json-schemas">Inferring and verifying against JSON schemas</h2>
<h2 id="a-nameperfperformance-considerationsa"><a name="perf">Performance considerations</a></h2>
<p>Using reflection to interpret Go language types dynamically,
as the VIPcode library currently does,
is undoubtably <em>not</em> the way to get the maximum possible performance
in marshaling and unmarshaling.
The presentation/interface separation and VIPcode philosophy
is not in any way incompatible with or opposed to
the idea of IDL stub compilation, however.
We can easily envision, and I hope someone will create,
a tool that compiles Go-language presentations
into highly-optimized statically-typed marshaling stubs
<em>and</em> verifies those presentations against abstract interface definitions
at the same time.
The result should combine the convenience and customizability
of target-language presenation definitions,
the interoperability of language-neutral interface definitions,
and the performance and efficiency of compiled marshaling stubs.</p>



    
      <br clear=all>
<hr>
<table width="100%"><tr>

<td align="left">

</td>

<td align="right">
<a href="https://bford.info/">Bryan Ford</a>
</td>

</tr></table>

    
  </body>
</html>
